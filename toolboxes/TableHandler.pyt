import arcpyimport sysfrom pathlib import Pathfrom importlib import reloadROOT = str(Path(__file__).parents[1].absolute()) # ../pyt_frameworkSHEET_NAME = "table_modification"if ROOT not in sys.path:    sys.path.insert(0, ROOT)if rf"{ROOT}\utils" not in sys.path:    sys.path.insert(1, rf"{ROOT}\utils")if rf"{ROOT}\enums" not in sys.path:    sys.path.insert(1, rf"{ROOT}\enums")if rf"{ROOT}\enums" not in sys.path:    sys.path.insert(1, rf"{ROOT}\configuration")# Import dynamic modules with pyt_reload prefiximport utils.common as pyt_reload_commonimport enums.excel_values as pyt_reload_excel_values# Inline reloader of dynamic modules[    print(f"Reloaded {reload(module).__name__}")    for module_name, module in globals().items()    if module_name.startswith("pyt_reload")]# Import the Tool Importer functionfrom utils.common import *from enums.excel_values import LayerNameExcelclass Toolbox:    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Toolbox"        self.alias = "toolbox"        # List of tool classes associated with this toolbox        self.tools = [Tool_1, Tool_2]class Tool_1:    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Create New Layer"        self.description = ""    def getParameterInfo(self):        """Define the tool parameters."""        param0 = arcpy.Parameter(        displayName="Layer Name",        name="layer_name",        datatype="GPString",        parameterType="Required",        direction="Input")        param0.filter.type = "ValueList"        param0.filter.list = ["line_remarks_discussion_1", "line_remarks_discussion_2"]        return [param0]    def isLicensed(self):        """Set whether the tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter. This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        SPATIAL_REFERENCE = arcpy.SpatialReference(2039)        aprx = arcpy.mp.ArcGISProject("CURRENT")        gdb_path = aprx.defaultGeodatabase        layer_name = parameters[0].valueAsText        configuration_path = os.path.join(ROOT, "configuration")        excel_path = os.path.join(configuration_path, "fields.xlsx")        arcpy.env.overwriteOutput = True        arcpy.CreateFeatureclass_management(gdb_path, layer_name, "Polyline", spatial_reference=SPATIAL_REFERENCE)        ws = load_excel_data(excel_path, SHEET_NAME)        add_fields_from_excel_to_layer(ws, layer_name, gdb_path)        aprx = arcpy.mp.ArcGISProject("CURRENT")        active_map = aprx.activeMap        active_map.addDataFromPath(os.path.join(gdb_path, layer_name))    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        returnclass Tool_2:    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Modify Layer"        self.description = ""    def getParameterInfo(self):        """Define parameter definitions"""        aprx = arcpy.mp.ArcGISProject("CURRENT")        default_gdb = aprx.defaultGeodatabase        param0 = arcpy.Parameter(            displayName="Select Feature Class",            name="in_fc",            datatype="GPString",            parameterType="Required",            direction="Input"        )        param0.filter.type = "ValueList"        param0.filter.list = []        param1 = arcpy.Parameter(        displayName="Layer Name",        name="layer_name",        datatype="GPString",        parameterType="Required",        direction="Input")        param1.filter.type = "ValueList"        param1.filter.list = ["final_stands_online_template", "kkl_line_remarks_online_template",        "survey_points"]        return [param0, param1]    def isLicensed(self):        """Set whether the tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        aprx = arcpy.mp.ArcGISProject("CURRENT")        default_gdb = aprx.defaultGeodatabase        if default_gdb:            arcpy.env.workspace = default_gdb            feature_classes = arcpy.ListFeatureClasses()            if feature_classes:                parameters[0].filter.list = feature_classes        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter. This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        configuration_path = os.path.join(ROOT, "configuration")        fields_excel_path = os.path.join(configuration_path, "fields.xlsx")        layer_name_excel = parameters[1].valueAsText        aprx = arcpy.mp.ArcGISProject("CURRENT")        gdb_path = aprx.defaultGeodatabase        layer_name = parameters[0].valueAsText        input_fields = [field.name for field in arcpy.ListFields(layer_name)]        ws = load_excel_data(fields_excel_path, SHEET_NAME)        col_idx = get_column_indices(ws)        exists_excel_rows = [        row        for row in ws.iter_rows(min_row=2, values_only=True)        if row[col_idx[ExcelColumns.TABLE_NAME.value]] == layer_name_excel        and row[col_idx[ExcelColumns.EXISTS.value]]        ]        for row in exists_excel_rows:            if row[col_idx[ExcelColumns.COMMON_ERROR.value]] in input_fields:                arcpy.management.AlterField(os.path.join(gdb_path, layer_name),                row[col_idx[ExcelColumns.COMMON_ERROR.value]],                row[col_idx[ExcelColumns.NAME.value]],                 row[col_idx[ExcelColumns.ALIAS.value]])        input_fields = [field.name for field in arcpy.ListFields(layer_name)]        exists_excel_fields = [        row[col_idx[ExcelColumns.NAME.value]]        for row in ws.iter_rows(min_row=2, values_only=True)        if row[col_idx[ExcelColumns.TABLE_NAME.value]] == layer_name_excel        and row[col_idx[ExcelColumns.EXISTS.value]]        ]        missing_fields = [field for field in exists_excel_fields if field not in input_fields]        if missing_fields:            arcpy.AddError(f"The following fields are missing in the input layer: {', '.join(missing_fields)}")            return        excel_fields = [        row[col_idx[ExcelColumns.NAME.value]] for row in ws.iter_rows(min_row=2, values_only=True)        if row[col_idx[ExcelColumns.TABLE_NAME.value]] == layer_name_excel    ]        layer_fields = [field.name for field in arcpy.ListFields(os.path.join(gdb_path, layer_name)) if not field.required]        fields_to_delete = [field for field in layer_fields if field not in excel_fields]        if fields_to_delete:            arcpy.DeleteField_management(os.path.join(gdb_path, layer_name), fields_to_delete)        for row in ws.iter_rows(min_row=2, values_only=True):            if row[col_idx[ExcelColumns.TABLE_NAME.value]] == layer_name_excel and row[col_idx[ExcelColumns.TO_ADD.value]]:                field_params = get_row_values(row, col_idx)                create_field(gdb_path, layer_name, **field_params)        active_map = aprx.activeMap        active_map.addDataFromPath(os.path.join(gdb_path, layer_name))        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return